# Bug Fix: Request/Document Save Cache Invalidation Issue

## Problem
When creating a request and filling a document, clicking save, then immediately reopening it, the data appeared to be gone. However, waiting for some time would show the data correctly.

## Root Cause
TanStack Query (React Query) was caching the old data after save operations. When a document or request was saved successfully to the database, the frontend cache was not invalidated, causing stale data to be displayed when reopening immediately.

## Solution
Added cache invalidation using `queryClient.invalidateQueries()` in the mutation hooks to ensure fresh data is fetched after save operations.

## Files Modified

### 1. frontend/src/features/request/hooks/usePatchDoc.js
- Added `useQueryClient` import
- Modified hook to accept `docId` parameter
- Added `onSuccess` callback to invalidate the specific document cache after save

### 2. frontend/src/features/request/hooks/usePatchRequest.js
- Added `useQueryClient` import
- Modified hook to accept `requestId` parameter
- Added `onSuccess` callback to invalidate:
  - Specific request cache (`req-${requestId}`)
  - All request list caches (`incoming-reqs`, `draft-reqs`, `submitted-reqs`)

### 3. frontend/src/features/request/components/Form.jsx
- Updated `usePatchDoc()` call to pass `id` parameter: `usePatchDoc(id)`

### 4. frontend/src/features/Inbox/RequestDetails.jsx
- Extracted `requestId` from searchParams
- Updated `usePatchRequest()` call to pass `requestId` parameter

### 5. frontend/src/features/request/components/NewRequestForm.jsx
- Updated `usePatchRequest()` call to pass `requestId` parameter

## Result
Now when users save a document or request, the cache is immediately invalidated. When they reopen the item, fresh data is fetched from the server, eliminating the delay issue.

## Date
2026-02-05

---

# Bug Fix: Date Field Label Display in Document Forms

## Problem
Date fields in document forms were displaying labels as floating placeholder text inside tiny input fields instead of proper labels above the input, making them extremely difficult to read and use.

## Root Cause
The JSON Forms renderer priority rank (3) was too low, causing Material UI's date picker renderer to take precedence over the custom InputFieldRenderer. Material UI's renderer uses floating labels which conflicted with the custom label display.

## Solution
Increased the InputFieldTester rank from 3 to 10 in the renderer configuration to ensure the custom InputFieldRenderer takes precedence over Material UI's default renderers.

## Files Modified

### 1. frontend/src/features/request/renderers/inputFieldTester.js
- Changed rank from `3` to `10`
- This ensures custom renderer takes precedence for string and number field types

## Result
Date fields now display proper labels above the input fields with adequate sizing, matching the design of other form fields.

## Date
2026-02-05

---

# Bug Fix: Documents Appear Empty When Reopened Immediately After Save

## Problem
After implementing initial cache invalidation, documents still appeared empty when users saved changes and immediately reopened the form. The stale data was being shown briefly before fresh data loaded.

## Root Cause
Using `invalidateQueries()` only marks cached data as stale but doesn't remove it immediately. When reopening a form quickly after save, the stale cached data was being displayed momentarily before refetching completed.

## Solution
Enhanced cache management by:
1. Using `removeQueries()` instead of `invalidateQueries()` to completely delete cached data
2. Adding `refetchOnMount: 'always'` to query hooks to force fresh data fetch on component mount

## Files Modified

### 1. frontend/src/features/request/hooks/usePatchDoc.js
- Changed `queryClient.invalidateQueries()` to `queryClient.removeQueries()`
- Completely removes document cache after successful save

### 2. frontend/src/features/request/hooks/usePatchRequest.js
- Changed `queryClient.invalidateQueries()` to `queryClient.removeQueries()` for specific request cache
- Keeps list invalidations using `invalidateQueries()` for efficiency

### 3. frontend/src/features/request/hooks/useDocData.js
- Added `refetchOnMount: 'always'` option to `useQuery`
- Ensures fresh data is always fetched when document form mounts

### 4. frontend/src/features/request/hooks/useRequestData.js
- Added `refetchOnMount: 'always'` option to `useQuery`
- Ensures fresh data is always fetched when request form mounts

## Result
Documents now display correctly when reopened immediately after saving. The cache is completely cleared on save, and fresh data is always fetched when reopening forms.

## Date
2026-02-05

---

# Bug Fix: MyWorkflows Page Scrolling Issue

## Problem
The MyWorkflows page was not scrolling to show all workflow instances. When there were many workflows, users couldn't see the complete list as the page was cut off.

## Root Cause
The `Page` styled component in `MyWorkflows.jsx` used `height: 100vh` which caused the page to overflow its parent container (the AppLayout's Container). The viewport height unit didn't account for the parent container's boundaries and padding.

## Solution
Changed the height property from `100vh` to `100%` so the page properly fits within the parent container and respects the layout boundaries.

## Files Modified

### 1. frontend/src/pages/MyWorkflows.jsx
- Changed `height: 100vh` to `height: 100%` in the Page styled component
- This ensures the page fits within the AppLayout Container and allows proper scrolling

## Result
Users can now scroll through all their workflows on the MyWorkflows page. The page properly fits within the layout container and overflow is handled correctly.

## Date
2026-02-05

---

# Bug Fix: Request Filters Not Working in Requests Page

## Problem
The filter and sort controls in the Requests page (submitted/draft requests) were not working. Clicking filter buttons (All, Pending, Approved, Rejected) or changing the sort order had no effect on the displayed requests.

## Root Cause
The `Filter` and `SortBy` components were correctly setting URL parameters (`status` and `sortBy`), but the `RequestsTable` component was not reading these parameters or applying any filtering/sorting to the data. The table simply displayed all requests from the API without any client-side filtering.

## Solution
Updated the `RequestsTable` component to:
1. Read the `status` filter from URL parameters and filter requests accordingly
2. Read the `sortBy` parameter and sort requests by date (ascending/descending)
3. Update pagination to use the filtered count instead of total count
4. Show empty state when filters return no results

## Files Modified

### 1. frontend/src/features/request/components/RequestsTable.jsx
- Added logic to read `status` URL parameter and filter requests by status
- Added logic to read `sortBy` URL parameter and sort requests by date
- Updated pagination to use filtered request count
- Added empty state check for filtered results

## Result
Users can now filter requests by status (All, Pending, Approved, Rejected) and sort by date. The table correctly updates to show only matching requests, and pagination reflects the filtered count.

## Date
2026-02-05

---

# Refactor: Move Request Filtering from Frontend to Backend

## Problem
The request filtering was being done on the frontend after fetching all requests. This approach:
- Downloads unnecessary data (all requests even when filtering)
- Inefficient for large datasets
- Pagination becomes inaccurate (shows total count instead of filtered count)

## Solution
Moved the filtering and sorting logic to the backend API:
1. Updated the API service to pass status and sort parameters
2. Backend already supports filtering/sorting via SequelizeQueryBuilder
3. Frontend now passes URL parameters directly to the API
4. Removed client-side filtering logic

## Files Modified

### 1. frontend/src/features/request/services/getMyRequests.js
- Added `status` and `sortBy` parameters to the function signature
- Build query parameters dynamically based on provided filters
- Map frontend field names (startDate) to database columns (createdAt)
- Convert sort direction to Sequelize format (+ for ASC, - for DESC)

### 2. frontend/src/features/request/hooks/useRequests.js
- Added `status` and `sortBy` parameters to the hook
- Updated query key to include filter/sort parameters for proper cache invalidation
- Pass parameters to the getMyRequests service

### 3. frontend/src/features/request/components/RequestsTable.jsx
- Read filter and sort parameters from URL at the top of the component
- Pass parameters directly to useRequests hook
- Removed all client-side filtering and sorting logic
- Simplified component - data now comes pre-filtered from backend

## Result
- More efficient data fetching - only requested data is transferred
- Accurate pagination - shows correct filtered count
- Better performance for large datasets
- Backend handles all filtering/sorting logic
- Frontend is simpler and more maintainable

## Date
2026-02-05
